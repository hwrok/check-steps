name: Check Steps
description: "checks step outcomes, prints statuses, and fails if any step did not succeed"

branding:
  color: 'green'
  icon: 'bar-chart-2'

inputs:
  steps:
    description: 'newline-separated, pipe-delimited list of "name|outcome" pairs'
    required: true

outputs:
  failed:
    description: 'whether any steps failed'
    value: ${{ steps.check.outputs.failed }}

runs:
  using: composite
  steps:
    - name: check steps
      id: check-steps
      shell: bash
      run: |
        RED="\033[0;31m"
        GREEN="\033[0;32m"
        YELLOW="\033[0;33m"
        RESET="\033[0m"
        
        all_failed=(
          "ğŸ’€ Wow. A clean sweep of failure. Impressive in its own way. ğŸ’€"
          "ğŸ° Jackpot! You managed to fail every single check. That takes skill. ğŸ°"
          "ğŸ§¨ Total annihilation. Not a single check survived. ğŸ§¨"
          "ğŸš© Red flags everywhere. You've set a new standard for broken code. ğŸš©"
          "âš°ï¸ Press F to pay respects. All checks have perished. âš°ï¸"
          "ğŸŒªï¸ Chaos incarnate. Nothing made it out alive. ğŸŒªï¸"
          "ğŸ’£ Mission failed successfully. Every. Single. One. ğŸ’£"
          "ğŸ´â€â˜ ï¸ Total shipwreck. Zero survivors detected. ğŸ´â€â˜ ï¸"
          "ğŸª Ladies and gentlemen, witness the rare full-spectrum failure! ğŸª"
          "ğŸ”» New record! 100% failure rate achieved. Stunning. ğŸ”»"
        )
        
        partial_failed=(
          "ğŸ’¥ Oh noes! Looks like somebody's PR didn't pass all the checks... Better luck next time, champ. ğŸ’¥"
          "ğŸš¨ Uh oh, spaghetti-o! Someone pushed code that doesn't quite... work. ğŸš¨"
          "ğŸ» Sad trombone: your code has failed the vibe check. ğŸ»"
          "ğŸ”¥ This is fine. (It's not fine.) ğŸ”¥"
          "ğŸš§ Caution: Some assembly required. (Your code is broken.) ğŸš§"
          "ğŸ² Mixed results. Spoiler: the failures are the problem. ğŸ²"
          "âš ï¸ Houston, we have... well, several problems actually. âš ï¸"
          "ğŸ›‘ Stop right there! You've got some issues to address. ğŸ›‘"
          "ğŸ“‰ Not great, not terrible. (It's terrible.) ğŸ“‰"
          "ğŸ­ The good, the bad, and the utterly broken. Guess which is which. ğŸ­"
        )
        
        all_success=(
          "âœ¨ Look at you, writing code that actually works. What a concept. âœ¨"
          "ğŸ‰ Congrats! You managed to not break everything. Gold star. ğŸ‰"
          "ğŸ‘ Slow clap for meeting the absolute bare minimum. ğŸ‘"
          "ğŸ† Achievement unlocked: Basic Competency. ğŸ†"
          "ğŸŒŸ All green! Someone's been reading the documentation. ğŸŒŸ"
          "ğŸŠ Perfect score! Try not to let it go to your head. ğŸŠ"
          "ğŸ’¯ 100% pass rate. You've peaked. It's all downhill from here. ğŸ’¯"
          "ğŸ¥‡ Gold medal in not completely screwing up. Impressive. ğŸ¥‡"
          "ğŸ¦„ A unicorn sighting: code that works on the first try. ğŸ¦„"
          "ğŸ¾ Pop the champagne! Everything passed. (For now.) ğŸ¾"
        )
        
        failures=()
        successes=()
        comment=""
        color=""
        padded_length=0
        
        while IFS='|' read -r name outcome; do
          [ -z "$name" ] && continue
        
          name_length=${#name}
          [ $((name_length + 1)) -gt $padded_length ] && padded_length=$((name_length + 1))
        
          if [ "$outcome" = "success" ]; then
            successes+=("$name:$outcome")
          else
            failures+=("$name:$outcome")
          fi
        done <<< "${{ inputs.steps }}"
        
        print_status() {
          local desc="$1"
          local outcome="$2"
          local padded_name=$(printf "%-${padded_length}s" "$desc")
          case "$outcome" in
            success) echo -e "  ${padded_name} : ${GREEN}${outcome}${RESET}" ;;
            failure) echo -e "  ${padded_name} : ${RED}${outcome}${RESET}" ;;
            *) echo -e "  ${padded_name} : ${YELLOW}${outcome}${RESET}" ;;
          esac
        }
        
        if [ ${#failures[@]} -gt 0 ] && [ ${#successes[@]} -eq 0 ]; then
          comment="${all_failed[$RANDOM % ${#all_failed[@]}]}"
          color="${RED}"
        elif [ ${#failures[@]} -gt 0 ]; then
          comment="${partial_failed[$RANDOM % ${#partial_failed[@]}]}"
          color="${RED}"
        elif [ ${#successes[@]} -gt 0 ] && [ ${#failures[@]} -eq 0 ]; then
          comment="${all_success[$RANDOM % ${#all_success[@]}]}"
          color="${GREEN}"
        fi
        
        echo ""
        echo -e "${color}${comment}${RESET}"
        echo ""
        
        if [ ${#failures[@]} -gt 0 ]; then
          title="FAILURE"
          bar_len=$(( ${#title} + 2 ))
        
          echo -e "${RED}â”Œ$(printf 'â”€%.0s' $(seq 1 $bar_len))â”${RESET}"
          echo -e "${RED}â”‚ ${title} â”‚${RESET}"
          echo -e "${RED}â””$(printf 'â”€%.0s' $(seq 1 $bar_len))â”˜${RESET}"
        
          for step in "${failures[@]}"; do
            IFS=':' read -r desc outcome <<< "$step"
            print_status "$desc" "$outcome"
          done
          echo ""
        fi
        
        if [ ${#successes[@]} -gt 0 ]; then
          title="SUCCESS"
          bar_len=$(( ${#title} + 2 ))
        
          echo -e "${GREEN}â”Œ$(printf 'â”€%.0s' $(seq 1 $bar_len))â”${RESET}"
          echo -e "${GREEN}â”‚ ${title} â”‚${RESET}"
          echo -e "${GREEN}â””$(printf 'â”€%.0s' $(seq 1 $bar_len))â”˜${RESET}"
        
          for step in "${successes[@]}"; do
            IFS=':' read -r desc outcome <<< "$step"
            print_status "$desc" "$outcome"
          done
        fi
        
        if [ ${#failures[@]} -gt 0 ]; then
          echo "failed=true" >> $GITHUB_OUTPUT
          exit 1
        else
          echo "failed=false" >> $GITHUB_OUTPUT
        fi
